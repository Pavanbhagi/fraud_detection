# Credit Card Detection System - Step-by-Step Explanation

## ğŸ“‹ Table of Contents
1. [System Overview](#system-overview)
2. [Architecture Flow](#architecture-flow)
3. [Step-by-Step Process](#step-by-step-process)
4. [Code Explanation](#code-explanation)
5. [How Each Component Works](#how-each-component-works)

---

## ğŸ¯ System Overview

This system detects credit cards in images and extracts information like:
- Card number (16 digits)
- Cardholder name
- Expiry date
- Validates card numbers using Luhn algorithm

**Technology Stack:**
- **OpenCV**: Image processing and card detection
- **Tesseract OCR**: Text extraction from images
- **Flask**: Web API framework
- **Python**: Programming language

---

## ğŸ”„ Architecture Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Input Image â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Image Preprocessing  â”‚ â† CLAHE, Denoising, Sharpening
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Contour Detection    â”‚ â† Find rectangular shapes
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Filter by Aspect     â”‚ â† Check if shape matches card ratio (1.586)
â”‚ Ratio & Size         â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Extract Card Region  â”‚ â† Crop detected card area
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ OCR Text Extraction  â”‚ â† Tesseract reads text
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Parse & Extract      â”‚ â† Find card number, name, expiry
â”‚ Information          â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Validate Card Number â”‚ â† Luhn algorithm check
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Return JSON Response â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ Step-by-Step Process

### **STEP 1: Image Input**
**What happens:**
- User uploads an image file (JPG, PNG, etc.)
- System reads the image using OpenCV (`cv2.imread()`)

**Code location:** `credit_card_detector.py` â†’ `process_image()` method

```python
image = cv2.imread(image_path)  # Read image from file
```

---

### **STEP 2: Image Preprocessing**
**What happens:**
The image is enhanced to improve detection accuracy:

1. **Convert to Grayscale**
   - Removes color information (not needed for shape detection)
   - Reduces processing complexity

2. **CLAHE (Contrast Limited Adaptive Histogram Equalization)**
   - Improves contrast in different lighting conditions
   - Makes edges more visible

3. **Denoising**
   - Removes image noise
   - Makes the image cleaner

4. **Sharpening**
   - Enhances edges and boundaries
   - Makes card edges more prominent

**Code location:** `credit_card_detector.py` â†’ `preprocess_image()` method

```python
# Convert to grayscale
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Enhance contrast
clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8))
enhanced = clahe.apply(gray)

# Remove noise
denoised = cv2.fastNlMeansDenoising(enhanced, h=10)

# Sharpen edges
kernel = np.array([[-1, -1, -1],
                  [-1,  9, -1],
                  [-1, -1, -1]])
sharpened = cv2.filter2D(denoised, -1, kernel)
```

**Why this matters:** Better preprocessing = better detection accuracy

---

### **STEP 3: Edge Detection**
**What happens:**
- Uses Canny edge detection to find boundaries
- Detects all edges in the image (card edges, text edges, etc.)

**Code location:** `credit_card_detector.py` â†’ `detect_card()` method

```python
edges = cv2.Canny(processed, 50, 150)  # Detect edges
```

**Visual result:** White lines on black background showing all edges

---

### **STEP 4: Contour Detection**
**What happens:**
- Finds all closed shapes (contours) in the edge image
- Each contour represents a potential object

**Code location:** `credit_card_detector.py` â†’ `detect_card()` method

```python
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
```

**Result:** List of all shapes found in the image

---

### **STEP 5: Filter Contours (Card Detection)**
**What happens:**
For each contour, the system checks:

1. **Size Filter**
   - Too small? â†’ Ignore (probably noise)
   - Too large? â†’ Ignore (probably the whole image)
   - Just right? â†’ Continue checking

2. **Aspect Ratio Filter**
   - Credit cards have a standard size: 85.6mm Ã— 53.98mm
   - Aspect ratio = 85.6 / 53.98 = **1.586**
   - System checks if contour ratio is between 1.3 and 1.8

3. **Confidence Calculation**
   - Closer to 1.586 = higher confidence
   - Confidence score: 0.5 to 1.0

**Code location:** `credit_card_detector.py` â†’ `detect_card()` method

```python
for contour in contours:
    area = cv2.contourArea(contour)
    if min_area < area < max_area:  # Size check
        x, y, width, height = cv2.boundingRect(contour)
        aspect_ratio = width / height
        
        if 1.3 < aspect_ratio < 1.8:  # Card ratio check
            # Calculate confidence
            ideal_ratio = 1.586
            confidence = 1.0 - abs(aspect_ratio - ideal_ratio) / ideal_ratio
```

**Result:** List of detected card regions with bounding boxes

---

### **STEP 6: Extract Card Region**
**What happens:**
- For each detected card, crop that region from the original image
- This gives us just the card area (not the whole image)

**Code location:** `credit_card_detector.py` â†’ `extract_card_info()` method

```python
x1, y1, x2, y2 = bbox  # Bounding box coordinates
card_roi = image[y1:y2, x1:x2]  # Crop card region
```

**Result:** Small image containing only the credit card

---

### **STEP 7: Prepare for OCR**
**What happens:**
- Convert card region to grayscale
- Resize to 2x larger (better OCR accuracy)
- Apply thresholding (black text on white background)

**Code location:** `credit_card_detector.py` â†’ `extract_card_info()` method

```python
roi_gray = cv2.cvtColor(card_roi, cv2.COLOR_BGR2GRAY)
roi_enhanced = cv2.resize(roi_gray, None, fx=2, fy=2)  # 2x larger
_, roi_thresh = cv2.threshold(roi_enhanced, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
```

**Why resize?** Larger text = easier for OCR to read

---

### **STEP 8: OCR Text Extraction**
**What happens:**
- Tesseract OCR reads all text from the card image
- Returns text with confidence scores

**Code location:** `credit_card_detector.py` â†’ `extract_card_info()` method

```python
ocr_text = pytesseract.image_to_string(roi_thresh, config='--oem 3 --psm 6')
```

**Result:** Raw text like:
```
"4532 1234 5678 9010
JOHN DOE
12/25"
```

---

### **STEP 9: Parse and Extract Information**
**What happens:**
The system searches the OCR text for:

1. **Card Number (16 digits)**
   - Looks for sequences of 16 digits
   - Removes spaces and dashes
   - Pattern: `\d{16}` or `\d{4} \d{4} \d{4} \d{4}`

2. **Expiry Date**
   - Looks for MM/YY or MM/YYYY format
   - Pattern: `\d{2}[/-]\d{2,4}`

3. **Cardholder Name**
   - Looks for uppercase text (letters only)
   - Must be longer than 5 characters
   - Pattern: `^[A-Z\s]+$`

**Code location:** `credit_card_detector.py` â†’ `extract_card_info()` method

```python
# Find 16-digit card number
numbers = re.findall(r'\d+', text.replace(' ', '').replace('-', ''))
for num in numbers:
    if len(num) == 16:
        card_number = num

# Find expiry date
expiry_match = re.search(r'(\d{2})[/-](\d{2,4})', text)

# Find name (uppercase letters)
if re.match(r'^[A-Z\s]+$', text.strip()) and len(text.strip()) > 5:
    cardholder_name = text.strip()
```

**Result:** Extracted structured data

---

### **STEP 10: Validate Card Number (Luhn Algorithm)**
**What happens:**
The Luhn algorithm checks if a card number is mathematically valid:

1. Start from the rightmost digit
2. Double every second digit (moving left)
3. If doubling results in 2-digit number, add the digits
4. Sum all digits
5. If sum is divisible by 10 â†’ Valid âœ…

**Example:**
```
Card: 4532 1234 5678 9010
Step 1: Reverse â†’ 0 1 0 9 8 7 6 5 4 3 2 1 2 3 5 4
Step 2: Double every 2nd â†’ 0 2 0 18 8 14 6 10 4 6 2 2 2 6 5 8
Step 3: Add digits â†’ 0 2 0 9 8 5 6 1 4 6 2 2 2 6 5 8
Step 4: Sum = 60
Step 5: 60 % 10 = 0 â†’ VALID âœ…
```

**Code location:** `credit_card_detector.py` â†’ `validate_card_number()` method

```python
def luhn_check(card_num):
    digits = [int(d) for d in str(card_num)]
    odd_digits = digits[-1::-2]      # Every 2nd from right
    even_digits = digits[-2::-2]     # Every other from right
    checksum = sum(odd_digits)
    for d in even_digits:
        checksum += sum([int(x) for x in str(d * 2)])
    return checksum % 10 == 0
```

**Result:** `is_valid: true` or `is_valid: false`

---

### **STEP 11: Return JSON Response**
**What happens:**
All extracted information is formatted as JSON and returned:

```json
{
  "num_cards_detected": 1,
  "cards": [
    {
      "card_number": "4532123456789010",
      "cardholder_name": "JOHN DOE",
      "expiry_date": "12/25",
      "is_valid": true,
      "detection_confidence": 0.95,
      "bbox": [100, 50, 400, 250],
      "all_text": [
        {"text": "4532 1234 5678 9010", "confidence": 0.8},
        {"text": "JOHN DOE", "confidence": 0.9},
        {"text": "12/25", "confidence": 0.85}
      ]
    }
  ]
}
```

---

## ğŸ” How Each Component Works

### **1. OpenCV (Computer Vision)**
- **Purpose**: Image processing and shape detection
- **Key Functions**:
  - `cv2.imread()`: Read images
  - `cv2.Canny()`: Edge detection
  - `cv2.findContours()`: Find shapes
  - `cv2.boundingRect()`: Get rectangle coordinates

### **2. Tesseract OCR (Optical Character Recognition)**
- **Purpose**: Read text from images
- **How it works**:
  1. Analyzes image pixel patterns
  2. Recognizes character shapes
  3. Converts to text
  4. Returns confidence scores

### **3. Flask API (Web Framework)**
- **Purpose**: Provide HTTP interface
- **Endpoints**:
  - `POST /detect`: Upload image, get results
  - `GET /health`: Check system status
  - `GET /`: API information

### **4. Luhn Algorithm (Validation)**
- **Purpose**: Validate card numbers
- **Why**: Catches typos and invalid numbers
- **Standard**: Used by all major card companies

---

## ğŸ“ Key Concepts Explained

### **Contour Detection**
- A contour is a curve joining continuous points with the same color/intensity
- Think of it as "tracing the outline" of objects
- Credit cards appear as rectangular contours

### **Aspect Ratio**
- Width divided by height
- Credit cards: ~1.586 (standard size)
- Helps filter out non-card shapes

### **OCR (Optical Character Recognition)**
- Technology that reads text from images
- Like a scanner reading printed text
- Not 100% accurate (depends on image quality)

### **Luhn Algorithm**
- Mathematical checksum formula
- Used to validate identification numbers
- Used by credit cards, IMEI numbers, etc.

---

## ğŸš€ Performance Tips

1. **Better Images = Better Results**
   - Good lighting
   - Clear focus
   - Minimal glare
   - Flat surface

2. **Preprocessing Matters**
   - CLAHE helps with varying lighting
   - Denoising removes artifacts
   - Sharpening enhances edges

3. **OCR Accuracy**
   - Larger text = better recognition
   - High contrast = better results
   - Clean background = fewer errors

---

## ğŸ“Š Example Flow Diagram

```
User uploads image.jpg
    â†“
[System reads image]
    â†“
[Preprocess: Grayscale â†’ CLAHE â†’ Denoise â†’ Sharpen]
    â†“
[Detect edges with Canny]
    â†“
[Find all contours]
    â†“
[Filter: Size + Aspect Ratio]
    â†“
Found 1 card! (confidence: 0.95)
    â†“
[Crop card region]
    â†“
[Resize 2x + Threshold]
    â†“
[Tesseract OCR reads text]
    â†“
Text: "4532 1234 5678 9010\nJOHN DOE\n12/25"
    â†“
[Parse: Number=4532123456789010, Name=JOHN DOE, Expiry=12/25]
    â†“
[Luhn check: Valid âœ…]
    â†“
Return JSON with all information
```

---

## ğŸ› ï¸ Troubleshooting

**Problem**: No cards detected
- **Solution**: Check image quality, adjust aspect ratio range

**Problem**: Wrong text extracted
- **Solution**: Improve image preprocessing, resize larger

**Problem**: Card number not found
- **Solution**: Check OCR output, adjust regex patterns

**Problem**: Low confidence scores
- **Solution**: Better image quality, adjust detection parameters

---

This system combines computer vision, OCR, and validation algorithms to create a complete credit card detection solution! ğŸ¯
